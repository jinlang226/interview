[reference](https://www.infoq.cn/profile/2E2516A8916716/publish)

# 存储

* 为了更好得支持对表的元数据的管理和变更操作, 分离元数据和数据的存储。把属性放在 csv 文件的第一行。比如有几个 namespace，对于每个 namespace 分别有几个表，每个表都有哪些属性。单独存储表的属性就更方便读取和管理。

* 为了更高效地实现增删改数据，引入 slot_table 以及标注信息来纪录对数据的增删改，并且引入 vacuum 操作定期清理无用的行数据

* 为了更高效得存储数据，用 byte 来存储数据配合高效的编码和解码算法来加速读取和写入
    * 用 raw byte 来存储数据配合高效的编码和解码算法来加速读取和写入。

* 为了应对数据仓库中复杂报表的查询语句和超大量的数据读取，引入列存概念，并且用压缩算法来进一步优化数据量
    * 把行存转换为列存，并且由于存储的数据是一个类型的，可以进一步用压缩算法来优化数据量。

# Index
## 哈希
希索引虽好，却也不是万能的。比如把查询条件从点查询改为范围查询

## B/ B+
于是我们引出第二个使用的数据结构 B 树和 B+树(B - tree, B+ - Tree)。B 树相当于把二分查找变成了 N 分查找，假设 N 为 100，那查找范围为(1, 100 万)就只需要 3 次分叉了(100^3 = 100 万)。B+树和 B 树的区别就在于 B 树在非叶节点也会存储数据而 B+树仅在页节点存储数据。下图示例为 B+树。

衍生出了合并前缀(prefix compression)以及删除无用后缀(suffix truncation)等的优化方法

为了能够进一步优化范围查询，我们引出了第二类索引，B 树索引

它有什么缺陷吗？B 树的实现，增加和删除数据会牵涉到节点的分离和合并，是比较复杂的(没有同学在面试过程中遇到要求实现 B 树这类的变态问题吧)。尤其是在高并发的环境下，对于节点的操作需要加锁， 会进一步导致速度变慢。

## skip list
有没有办法进一步改进吗？有！有一种比较偏门的数据结构 – 跳表(skip list)比 B 树在这方面就更优秀。跳表的实现是一个多层次的链表，底部链表和 B 树一样是一列有序的键值对，通过在上层加入更松散的有序链表来支持跳跃查询(命名的由来)。下图给出了跳表示例。


### skip list over red black: memory, zrange
红黑树在插入和删除的时候可能需要做一些rebalance的操作，这样的操作可能会涉及到整个树的其他部分，而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些。

## 位图索引
存储需求很小：对于每个基数，每一行数据只要 1bit 的存储。所以当列的基数很大时，位图索引就失去意义了。位图索引的另一个劣势在于，不适用于高并发环境，因为任何修改和添加，都需要对索引文件进行加锁。

(raft)[https://www.cnblogs.com/xybaby/p/10124083.html]

# 执行模式
编译(parsing)，绑定(binding)，优化(optimizing)，执行(executing)
第一步是通过编译器(parser)把语句编译成抽象语法树(Abstracted Syntax Tree)。这一步的主要过程就是确保输入语句没有 SQL 语法和词法错误。绑定器的作用就是将语法树通过和数据库的元数据(metadata)结合，为它附上语义(semantic)
优化器会先生成一个逻辑执行树(logical operator tree)
从执行树的底层，由读取表数据开始，依次向上执行

执行：
1）materialization 模式：执行的过程自底向上，每个节点都一次性处理所有数据。优势是实现简单，但对于数据量很大的 OLAP 语句不太合适，但比较适合单次操作数据量较小的 OLTP(online transactional processing)语句。

2）迭代模式(或者叫 volcano model): 一种通用的执行模式。流式的执行过程，数据以一个一个 tuple 形式传递与操作符之间。有一些操作符会需要阻塞等待所有数据，需要 spill to disk 实现。缺点是实现复杂，由于操作符之间不断交互，所以效率相对较低。

3）向量模式：介于前两者之间，批量处理数据。更好地利用 SIMD 来提高执行速度。对于大量数据处理比迭代模式高效，所以也更适合 OLAP 语句。


# join
说了那么多种 JOIN，读者可能会想，即然已经说了 HashJoin 普遍情况下性能最优，为什么还需要实现其他 JOIN 呢？因为在特定的情况下，NestedLoopIndexScan 可能会比 HashJoin 更快，或者在需要排序的情况下，SortMergeJoin 也可能更有优势。影响因素有具体的查询语句，表 A 和表 B 的大小，join 键值的分布，以及是否对 join 键值有 index 等等。数据库在执行语句的时候，需要通盘考虑这些影响因素来决定最后具体使用哪种 JOIN 算子。而做这个决定的就是咱们下一期要讲的内容：数据库的大脑 – 优化器。尽情期待。

# 优化
SQL 是一种 declarative language(声明式语言)，它只是告知了数据库系统，它希望数据以什么形式返回，但并没有告诉系统，要怎么去一步一步执行算子来得到最终结果

除了时间，还有什么可以优化的维度呢？比如计算资源，一个查询语句，需要发生多少次 IO，使用多少内存，总共运行多少个 CPU cycle，耗费了多少电量

今天我们先从 join ordering 问题讲起，介绍了 cardinality estimation 技术，它通过预测 selection cardinality 和 join cardinality 来帮助决定 join ordering。然后介绍了 cost model 来对每个对应的 physical operator 计算 cost。最后通过 dynamic programming 来求解最小 cost 的 physical operator tree，以此得到最终的 physical execution plan。

# 事务
https://www.infoq.cn/article/teJA7X43BO2alp6rLCWk

事务的定义是：一个事务是一组对数据库中数据操作的集合。无论集合中有多少操作，对于用户来说，只是对数据库状态的一个原子改变。

## 隔离级别

1）读未提交：在一个事务中，允许读取其他事务未提交的数据。
2）读提交：在一个事务中，只能够读取到其他事务已经提交的数据。
3）可重复读：在一个事务中，只能读取已经提交的数据，且可以重复查询这些数据，并且，在重复查询之间，不允许其他事务对这些数据进行写操作。
4）可有序化：所有的事务必须按照一定顺序执行。

而后三种隔离级别分别为了解决前一种隔离级别遇到的问题：
1）脏读：一个事务读取了另一个事务还未提交的修改。
2）不可重复度：在一个事务过程中，可能出现多次读取同一数据但得到不同值的现象。
3）幻读：在一个事务中，当查询了一组数据后，再次发起相同查询，却发现满足条件的数据被另一个提交的事务改变了。

## 事务的实现
### 加锁实现机制(Lock-based protocols)
实现事务隔离的最简单方法就是在对任何数据进行读写时，都保证互斥性，即当一个事务在读写数据时，保证其他事务不能对数据进行修改。最常见的实现就是对数据进行加锁(lock)。

1）共享锁(share-mode lock; S-lock)，即当事务获得了某个数据的共享锁，它仅能对该数据进行读操作，但不能写，共享锁有时候也被称为读锁。2）独占锁(exclusive-mode lock; X-lock)，即当事务获得了某个数据的独占锁，它可以对数据进行读和写操作，独占锁也常被叫做写锁。共享锁和独占锁的兼容模式如下：

我们引入了第一个加锁实现：两阶段加锁机制(Two-phase locking protocol)。它要求事务在加锁的过程中遵循下面两步：
1）获取锁阶段(growing phase)：在这个过程中，事务只能不断地获取新的锁，但不能释放锁。
2）释放锁阶段(shrinking phase)：在这个过程中，事务只能逐渐释放锁，并且无权再获取新的锁。

### 时间戳机制(Timestamp-based protocols)
可以用数字计数(logical counter)来表示相对时间。管理线程只需维护一个计数，在分发计数的同时不断自增即可。

### 多版本并发控制 Multi-Version Concurrency Control (MVCC)
把每个数据的所有历史版本都记录下来，就可以避免上述这种情况发生
多版本时间戳机制的一大好处在于，一个读取数据的事务永远不会失败也不需要等待。在一个读多写少的场景下，相比于先前介绍的两种机制，会有很好的性能提升。
当然，它也是有缺点的。首先，就是在读取操作的事务中，也需要更新相应的 R-TS(Qk)，并且读取数据，这就导致可能产生两次磁盘操作，而非只读一次。另外，当写操作发生冲突时，它会要求回滚失败的事务，相比起等待，回滚操作可能更昂贵一些。下面介绍的另一种的实现可以解决这个问题。
#### 多版本两阶段加锁(Multi-Version Two-Phase Locking)
#### 快照隔离(Snapshot Isolation)
快照隔离可以看作是对每一个事务，分配了一个独有的数据库快照。事务可以安心地读取这个快照中的数据而不需要去担心其他事务(因此只读事务是不会失败也不会被等待的)
快照隔离是一个单独的隔离级别而不是可有序化呢